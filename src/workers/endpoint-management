const ENDPOINTS = {
  'ent_zone': {
    handler: handleEntZone,
    label: 'Ent Zone',
    useZoneId: false
  },

  'data_transfer_request': {
    handler: handleDataTransferRequest,
    label: 'Data Transfer/Request',
    useZoneId: true
  },
  'bot_management_request': {
    handler: handleBotManagementRequest,
    label: 'Bot Management Request',
    useZoneId: true
  },
  'foundation_dns_queries': {
    handler: handleFoundationDNSQueries,
    label: 'Foundation DNS Queries',
    useZoneId: true
  },
  'china_ntw_data_transfer': {
    handler: handleChinaNtwDataTransfer,
    label: 'China NTW Data Transfer',
    useZoneId: true
  },
  'workers_std_requests': {
    handler: handleWorkersStdRequests,
    label: 'Workers STD Requests'
  },
  'workers_std_cpu': {
    handler: handleWorkersStdCPU,
    label: 'Workers STD CPU'
  },
  'workers_kv_read': {
    handler: handleWorkersKVOperations,
    label: 'Workers KV Read'
  },
  'workers_kv_storage': {
    handler: handleWorkersKVOperations,
    label: 'Workers KV Storage'
  },
  'workers_kv_write_list_delete': {
    handler: handleWorkersKVOperations,
    label: 'Workers KV Write List Delete'

  },
  'stream_minutes_stored': {
    handler: handleStreamMinutesStored,
    label: 'Stream Minutes Stored'
  },
  'stream_minutes_viewed': {
    handler: handleStreamMinutesViewed,
    label: 'Stream Minutes Viewed'
  },
  'images_delivered': {
    handler: handleImagesDelivered,
    label: 'Images Delivered'
  },
  'images_stored': {
    handler: handleImagesStored,
    label: 'Images Stored'
  },
  'images_unique_transformations': {
    handler: handleImagesUniqueTransformations,
    label: 'Images Unique Transformations'
  }
};

const AUTH_EMAIL = 'hakang@mz.co.kr';
const AUTH_KEY = 'f6f652701a00dc80fc3c5e764adb1b84461e3';

addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});


async function handleRequest(request) {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
  };

  if (request.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  if (request.method === 'GET') {
    // Handle GET request for endpoints
    const endpoints = Object.entries(ENDPOINTS).map(([key, value]) => ({
      value: key,
      label: value.label
    }));
    return new Response(JSON.stringify(endpoints), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
  
  if (request.method === 'POST') {
    try {
      const { accountTag, customerName, startDate, endDate, endpoints, zoneIds } = await request.json();
      
      if (!accountTag || !customerName || !startDate || !endDate || !endpoints || endpoints.length === 0 || !zoneIds || zoneIds.length === 0) {
        return new Response('Missing required parameters', { 
          status: 400,
          headers: corsHeaders
        });
      }
  
      const results = {};
      for (const endpoint of endpoints) {
        const endpointConfig = ENDPOINTS[endpoint];
        if (endpointConfig) {
          try {
            if (endpointConfig.useZoneId) {
              if (endpoint === 'foundation_dns_queries') {
                results[endpoint] = await endpointConfig.handler(
                  accountTag,
                  zoneIds,
                  { get: (key) => key === 'start_date' ? startDate : endDate }
                );
              } else if (endpoint === 'data_transfer_request' || endpoint === 'bot_management_request') {
                let totalBytes = 0;
                let totalRequests = 0;
                let totalLikelyHuman = 0;
                for (const zoneId of zoneIds) {
                  try {
                    const result = await endpointConfig.handler(
                      accountTag, 
                      zoneId, 
                      { get: (key) => key === 'start_date' ? startDate : endDate }
                    );
                    if (endpoint === 'data_transfer_request') {
                      const group = result.data.viewer.zones[0].httpRequestsOverviewAdaptiveGroups[0];
                      totalBytes += group.sum.bytes;
                      totalRequests += group.sum.requests;
                    } else if (endpoint === 'bot_management_request') {
                      const likelyHuman = result.data.viewer.zones[0].likely_human[0];
                      totalLikelyHuman += likelyHuman.count;
                    }
                  } catch (zoneError) {
                    console.error(`Error processing zoneId ${zoneId} for endpoint ${endpoint}:`, zoneError);
                  }
                }
                results[endpoint] = endpoint === 'data_transfer_request'
                  ? { totalBytes, totalRequests }
                  : { totalLikelyHuman };
              } else {
                let totalResult = [];
                for (const zoneId of zoneIds) {
                  try {
                    const result = await endpointConfig.handler(
                      accountTag, 
                      zoneId, 
                      { get: (key) => key === 'start_date' ? startDate : endDate }
                    );
                    totalResult.push({ zoneId, result });
                  } catch (zoneError) {
                    console.error(`Error processing zoneId ${zoneId} for endpoint ${endpoint}:`, zoneError);
                    totalResult.push({ zoneId, error: zoneError.message });
                  }
                }
                results[endpoint] = totalResult;
              }
            } else {
              results[endpoint] = await endpointConfig.handler(
                accountTag, 
                null, 
                { get: (key) => key === 'start_date' ? startDate : endDate }
              );
            }
          } catch (endpointError) {
            console.error(`Error processing endpoint ${endpoint}:`, endpointError);
            results[endpoint] = { error: endpointError.message || "Unknown error occurred" };
          }
        }
      }
  
      return new Response(JSON.stringify(results), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    } catch (error) {
      return new Response(JSON.stringify({ error: error.message }), { 
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
  }

  return new Response('Method not allowed', { status: 405, headers: corsHeaders });
}



function processEndpointResult(endpoint, result) {
  if (!result.data || !result.data.viewer || !result.data.viewer.zones || result.data.viewer.zones.length === 0) {
    console.error(`Invalid result structure for endpoint ${endpoint}:`, result);
    return null;
  }
  
  const account = result.data.viewer.accounts[0];

  switch (endpoint) {
    case 'data_transfer_request':
      if (result.bytes !== undefined && result.requests !== undefined) {
        return result;
      }
      return null;
    case 'bot_management_request':
      if (typeof result === 'number') {
        return result;
      }
      return null;

    case 'foundation_dns_queries':
      return result.data.viewer.zones[0].dns.analytics.queries.count;

    case 'workers_kv_read':
      return account.reads[0]?.sum.requests || 0;
    case 'workers_kv_storage':
      return account.storage[0]?.max.byteCount || 0;
    case 'workers_kv_write_list_delete':
      const writeRequests = account.writes[0]?.sum.requests || 0;
      const listRequests = account.lists[0]?.sum.requests || 0;
      const deleteRequests = account.deletes[0]?.sum.requests || 0;
      return {
        writeRequests,
        listRequests,
        deleteRequests,
        totalRequests: writeRequests + listRequests + deleteRequests
      };


    case 'china_ntw_data_transfer':
      const chinaGroups = result.data.viewer.zones[0].httpRequests1dGroups;
      return chinaGroups && chinaGroups.length > 0 ? chinaGroups[0].sum.bytes : null;
    // 다른 엔드포인트에 대한 처리를 추가할 수 있습니다.
    default:
      console.error(`Unknown endpoint: ${endpoint}`);
      return null;
  }
}


async function getZoneIds(customerName) {
  // KV에서 고객사의 zone ID들을 가져옵니다.
  const zonesData = await ZONES.get(`zones_${customerName}`);
  if (!zonesData) {
    throw new Error(`No zones found for customer: ${customerName}`);
  }
  const zones = JSON.parse(zonesData);
  return Object.values(zones);
}

async function performGraphQLRequest(query, variables = {}) {
  const response = await fetch('https://api.cloudflare.com/client/v4/graphql', {
    method: 'POST',
    headers: {
      'X-Auth-Email': AUTH_EMAIL,
      'X-Auth-Key': AUTH_KEY,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ query, variables })
  });
  return await response.json();
}


// 각 엔드포인트 결과를 처리하는 함수=======================================================================================================
async function handleEntZone(accountTag) {
  const url = `https://api.cloudflare.com/client/v4/accounts/${accountTag}`;
  try {
    const response = await fetch(url, {
      headers: {
        'X-Auth-Email': AUTH_EMAIL,
        'X-Auth-Key': AUTH_KEY,
        'Content-Type': 'application/json'
      }
    });
    const data = await response.json();
    if (data.success && data.result && data.result.legacy_flags && data.result.legacy_flags.enterprise_zone_quota) {
      const { maximum, current } = data.result.legacy_flags.enterprise_zone_quota;
      return { maximum, current };
    } else {
      throw new Error('Invalid response structure');
    }
  } catch (error) {
    console.error('Error fetching Ent Zone data:', error);
    return { error: error.message };
  }
}



// handleDataTransferRequest 함수 수정
async function handleDataTransferRequest(accountTag, zoneId, params) {
  const query = `
    query getDataTransferRequest($zoneTag: String!, $filter: ZoneHttpRequestsAdaptiveGroupsFilter_InputObject!) {
      viewer {
        zones(filter: { zoneTag: $zoneTag }) {
          httpRequestsOverviewAdaptiveGroups(limit: 1, filter: $filter) {
            sum {
              bytes
              requests
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    zoneTag: zoneId, 
    filter: {
      date_geq: params.get('start_date'),
      date_leq: params.get('end_date')
    }
  });
}

async function handleBotManagementRequest(accountTag, zoneId, params) {
  const query = `
    query getBotManagementRequests($zoneTag: String!, $filter: ZoneHttpRequestsAdaptiveGroupsFilter_InputObject!, $likelyHumanFilter: ZoneHttpRequestsAdaptiveGroupsFilter_InputObject!) {
      viewer {
        zones(filter: {zoneTag: $zoneTag}) {
          likely_human: httpRequestsAdaptiveGroups(filter: {AND: [ {botManagementDecision_neq: "verified_bot"}, $likelyHumanFilter ]}, limit: 10000) {
            count
          }
        }
      }
    }
  `;

  const variables = {
    zoneTag: zoneId,
    filter: {
      requestSource: "eyeball",
      date_geq: params.get('start_date'),
      date_leq: params.get('end_date'),
      botManagementDecision_neq: "other"
    },
    likelyHumanFilter: {
      requestSource: "eyeball",
      botScore_geq: 30,
      botScore_leq: 99,
      date_geq: params.get('start_date'),
      date_leq: params.get('end_date'),
      botManagementDecision_neq: "other"
    }
  };

  return await performGraphQLRequest(query, variables);
}

//====================================================FoundationDNS===================================================

async function handleFoundationDNSQueries(accountTag, zoneIds, params) {
  const startDate = params.get('start_date');
  const endDate = params.get('end_date');
  
  let zoneResults = {};
  let totalQueryCount = 0;
  let validZoneCount = 0;

  for (const zoneId of zoneIds) {
    const url = `https://api.cloudflare.com/client/v4/zones/${zoneId}/dns_analytics/report?metrics=queryCount&sort=-queryCount&limit=100&since=${startDate}T00:00:00Z&until=${endDate}T00:00:00Z`;

    try {
      const response = await fetch(url, {
        headers: {
          'X-Auth-Email': AUTH_EMAIL,
          'X-Auth-Key': AUTH_KEY,
          'Content-Type': 'application/json'
        }
      });

      const data = await response.json();
      zoneResults[zoneId] = data;

      // Check if the response contains valid query count data
      if (data.success && data.result && data.result.totals && data.result.totals.queryCount) {
        totalQueryCount += data.result.totals.queryCount;
        validZoneCount++;
      }
    } catch (error) {
      console.error(`Error fetching data for zone ${zoneId}:`, error);
      zoneResults[zoneId] = { error: error.message };
    }
  }

  return {
    zoneResults,
    summary: {
      totalQueryCount,
      validZoneCount,
      averageQueryCount: validZoneCount > 0 ? totalQueryCount / validZoneCount : 0
    }
  };
}



//====================================================Workers_KV===================================================
async function handleWorkersKVOperations(accountTag, zoneId, params) {
  const startDate = new Date(params.get('start_date')).toISOString();
  const endDate = new Date(params.get('end_date')).toISOString();
  console.log('Handling KV Operations with:', { accountTag, startDate, endDate });

  const query = `
    query KVOperationsSummaryByAccount($accountTag: String!, $startDate: String!, $endDate: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          reads: kvOperationsAdaptiveGroups(limit: 1, filter: {actionType: read, datetime_geq: $startDate, datetime_leq: $endDate}) {
            sum {
              requests
            }
          }
          writes: kvOperationsAdaptiveGroups(limit: 1, filter: {actionType: write, datetime_geq: $startDate, datetime_leq: $endDate}) {
            sum {
              requests
            }
          }
          lists: kvOperationsAdaptiveGroups(limit: 1, filter: {actionType: list, datetime_geq: $startDate, datetime_leq: $endDate}) {
            sum {
              requests
            }
          }
          deletes: kvOperationsAdaptiveGroups(limit: 1, filter: {actionType: delete, datetime_geq: $startDate, datetime_leq: $endDate}) {
            sum {
              requests
            }
          }
          storage: kvStorageAdaptiveGroups(limit: 744, filter: {datetime_geq: $startDate, datetime_leq: $endDate}) {
            max {
              byteCount
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    startDate,
    endDate
  });
}



//====================================================ChinaNtwDataTransfer===================================================
async function handleChinaNtwDataTransfer(accountTag, zoneIds, params) {
  const query = `
    query getChinaDataTransfer($zoneTag: String!, $filter: ZoneHttpRequestsAdaptiveGroupsFilter_InputObject!) {
      viewer {
        zones(filter: {zoneTag: $zoneTag}) {
          httpRequestsAdaptiveGroups(limit: 1, filter: $filter) {
            sum {
              edgeResponseBytes
            }
          }
        }
      }
    }
  `;

  let zoneResults = [];

  // zoneIds가 배열인지 확인하고, 배열이 아니면 배열로 변환
  const zoneIdsArray = Array.isArray(zoneIds) ? zoneIds : [zoneIds];

  for (const zoneId of zoneIdsArray) {
    try {
      const result = await performGraphQLRequest(query, { 
        zoneTag: zoneId,  // zoneId를 그대로 사용
        filter: {
          date_geq: params.get('start_date'),
          date_leq: params.get('end_date'),
          clientCountryName: "CN",
          requestSource: "eyeball"
        }
      });

      zoneResults.push({ zoneId, result });
    } catch (error) {
      console.error(`Error processing zoneId ${zoneId} for China NTW Data Transfer:`, error);
      zoneResults.push({ zoneId, error: error.message });
    }
  }

  return zoneResults;
}

//====================================================Workers_Std_Request===================================================
async function handleWorkersStdRequests(accountTag, zoneId, params) {
  const query = `
    query getBillingMetrics($accountTag: String!, $filter: AccountWorkersInvocationsAdaptiveFilter_InputObject) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          workersInvocationsAdaptive(limit: 10000, filter: $filter) {
            sum {
              Standatd_request: requests
            }
            dimensions {
              usageModel
            }
          }
        }
      }
    }
  `;
  
  const startDate = params.get('start_date');
  const endDate = params.get('end_date');
  
  const variables = {
    accountTag,
    filter: {
      date_geq: startDate,
      date_leq: endDate
    }
  };

  const result = await performGraphQLRequest(query, variables);
  
  // 전체 쿼리 응답을 콘솔에 로그
  console.log('Workers STD Requests Query Response:', JSON.stringify(result, null, 2));

  // 결과 전체를 반환
  return result;
}

//====================================================Workers_Std_CPU===================================================
async function handleWorkersStdCPU(accountTag, zoneId, params) {
  const query = `
    query getBillingMetrics($accountTag: String!, $overviewFilter: AccountWorkersInvocationsAdaptiveFilter_InputObject) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          workersOverviewRequestsAdaptiveGroups(limit: 1000, filter: $overviewFilter) {
            sum {
              CPU_Time: cpuTimeUs
            }
            dimensions {
              usageModel
            }
          }
        }
      }
    }
  `;
  
  const startDate = params.get('start_date');
  const endDate = params.get('end_date');
  
  const variables = {
    accountTag,
    overviewFilter: {
      datetime_geq: `${startDate}T00:00:00.000Z`,
      datetime_leq: `${endDate}T23:59:59.999Z`
    }
  };

  const result = await performGraphQLRequest(query, variables);
  
  // 전체 쿼리 응답을 콘솔에 로그
  console.log('Workers STD CPU Query Response:', JSON.stringify(result, null, 2));

  // 결과 전체를 반환
  return result;
}


async function handleStreamMinutesStored(accountTag, zoneId, params) {
  const query = `
    query getStreamMinutesStored($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          stream {
            minutesStored(filter: {date_geq: $start, date_leq: $end}) {
              sum {
                minutes
              }
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleStreamMinutesViewed(accountTag, zoneId, params) {
  const query = `
    query getStreamMinutesViewed($accountTag: String!, $filter: AccountStreamMinutesViewedAdaptiveGroupsFilter_InputObject!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          Total: streamMinutesViewedAdaptiveGroups(filter: $filter, limit: 10000) {
            sum {
              minutesViewed
            }
          }
        }
      }
    }
  `;
  
  const variables = {
    accountTag,
    filter: {
      date_geq: params.get('start_date'),
      date_leq: params.get('end_date')
    }
  };

  return await performGraphQLRequest(query, variables);
}

async function handleImagesDelivered(accountTag, zoneId, params) {
  const query = `
    query getImagesDelivered($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          imagesAdaptiveGroups(filter: {date_geq: $start, date_leq: $end}) {
            sum {
              requests
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleImagesStored(accountTag, zoneId, params) {
  const query = `
    query getImagesStored($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          imagesAdaptiveGroups(filter: {date_geq: $start, date_leq: $end}) {
            sum {
              bytes
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleImagesUniqueTransformations(accountTag, zoneId, params) {
  const query = `
    query getImagesUniqueTransformations($accountTag: String!, $filter: AccountImagesUniqueTransformationAdaptiveGroupsFilter_InputObject!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          imagesUniqueTransformations(filter: $filter, limit: 10000) {
            transformations
            date
          }
        }
      }
    }
  `;
  
  const variables = {
    accountTag,
    filter: {
      date_geq: params.get('start_date'),
      date_leq: params.get('end_date')
    }
  };

  return await performGraphQLRequest(query, variables);
}
