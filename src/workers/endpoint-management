const ENDPOINTS = {
  'data_transfer_request': {
    handler: handleDataTransferRequest,
    label: 'Data Transfer/Request',
    useZoneId: true
  },
  'bot_management_request': {
    handler: handleBotManagementRequest,
    label: 'Bot Management Request',
    useZoneId: true
  },
  'foundation_dns_queries': {
    handler: handleFoundationDNSQueries,
    label: 'Foundation DNS Queries',
    useZoneId: true
  },
  'china_ntw_data_transfer': {
    handler: handleChinaNtwDataTransfer,
    label: 'China NTW Data Transfer'
  },
  'workers_std_requests': {
    handler: handleWorkersStdRequests,
    label: 'Workers STD Requests'
  },
  'workers_std_cpu': {
    handler: handleWorkersStdCPU,
    label: 'Workers STD CPU'
  },
  'workers_kv_read': {
    handler: handleWorkersKVRead,
    label: 'Workers KV Read'
  },
  'workers_kv_storage': {
    handler: handleWorkersKVStorage,
    label: 'Workers KV Storage'
  },
  'workers_kv_write_list_delete': {
    handler: handleWorkersKVWriteListDelete,
    label: 'Workers KV Write List Delete'
  },
  'stream_minutes_stored': {
    handler: handleStreamMinutesStored,
    label: 'Stream Minutes Stored'
  },
  'stream_minutes_viewed': {
    handler: handleStreamMinutesViewed,
    label: 'Stream Minutes Viewed'
  },
  'images_delivered': {
    handler: handleImagesDelivered,
    label: 'Images Delivered'
  },
  'images_stored': {
    handler: handleImagesStored,
    label: 'Images Stored'
  },
  'images_unique_transformations': {
    handler: handleImagesUniqueTransformations,
    label: 'Images Unique Transformations'
  }
};

const AUTH_EMAIL = 'hakang@mz.co.kr';
const AUTH_KEY = 'f6f652701a00dc80fc3c5e764adb1b84461e3';

addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
  };

  if (request.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  if (request.method === 'GET') {
    // Handle GET request for endpoints
    const endpoints = Object.entries(ENDPOINTS).map(([key, value]) => ({
      value: key,
      label: value.label
    }));
    return new Response(JSON.stringify(endpoints), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
  
  if (request.method === 'POST') {
    try {
      const { accountTag, customerName, startDate, endDate, endpoints, zoneIds } = await request.json();
      
      if (!accountTag || !customerName || !startDate || !endDate || !endpoints || endpoints.length === 0 || !zoneIds || zoneIds.length === 0) {
        return new Response('Missing required parameters', { 
          status: 400,
          headers: corsHeaders
        });
      }
  
      const results = {};
      for (const endpoint of endpoints) {
        const endpointConfig = ENDPOINTS[endpoint];
        if (endpointConfig) {
          try {
            if (endpointConfig.useZoneId) {
              if (endpoint === 'foundation_dns_queries') {
                // Foundation DNS Queries에 대한 특별 처리
                results[endpoint] = await endpointConfig.handler(
                  accountTag,
                  zoneIds,
                  { get: (key) => key === 'start_date' ? startDate : endDate }
                );
              } else {
                let totalResult = endpoint === 'data_transfer_request' ? { bytes: 0, requests: 0 } : 0;
                let validResultCount = 0;
                for (const zoneId of zoneIds) {
                  try {
                    const result = await endpointConfig.handler(
                      accountTag, 
                      zoneId, 
                      { get: (key) => key === 'start_date' ? startDate : endDate }
                    );
                    
                    const processedResult = processEndpointResult(endpoint, result);
                    if (processedResult !== null) {
                      if (endpoint === 'data_transfer_request') {
                        totalResult.bytes += processedResult.bytes || 0;
                        totalResult.requests += processedResult.requests || 0;
                      } else {
                        totalResult += processedResult;
                      }
                      validResultCount++;
                    }
                  } catch (zoneError) {
                    console.error(`Error processing zoneId ${zoneId} for endpoint ${endpoint}:`, zoneError);
                  }
                }
                if (validResultCount > 0) {
                  results[endpoint] = totalResult;
                } else {
                  results[endpoint] = { 
                    errors: [{ message: "No valid results found for any zone" }]
                  };
                }
              }
            } else {
              // accountTag를 사용하는 엔드포인트는 기존 방식대로 처리합니다.
              results[endpoint] = await endpointConfig.handler(
                accountTag, 
                null, 
                { get: (key) => key === 'start_date' ? startDate : endDate }
              );
            }
          } catch (endpointError) {
            console.error(`Error processing endpoint ${endpoint}:`, endpointError);
            results[endpoint] = { 
              errors: [{ message: endpointError.message || "Unknown error occurred" }]
            };
          }
        }
      }
  
      return new Response(JSON.stringify(results), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    } catch (error) {
      return new Response(JSON.stringify({ error: error.message }), { 
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
  }

  return new Response('Method not allowed', { status: 405, headers: corsHeaders });
}


// 각 엔드포인트 결과를 처리하는 함수=======================================================================================================
async function handleDataTransferRequest(accountTag, zoneId, params) {
  const query = `
    query getDataTransferRequest($zoneTag: String!, $filter: ZoneHttpRequestsAdaptiveGroupsFilter_InputObject!) {
      viewer {
        zones(filter: { zoneTag: $zoneTag }) {
          httpRequestsOverviewAdaptiveGroups(limit: 1, filter: $filter) {
            sum {
              bytes
              requests
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    zoneTag: zoneId, 
    filter: {
      date_geq: params.get('start_date'),
      date_leq: params.get('end_date')
    }
  });
}


async function handleBotManagementRequest(accountTag, zoneId, params) {
  const query = `
    query getBotManagementRequests($zoneTag: String!, $filter: ZoneHttpRequestsAdaptiveGroupsFilter_InputObject!, $likelyHumanFilter: ZoneHttpRequestsAdaptiveGroupsFilter_InputObject!) {
      viewer {
        zones(filter: {zoneTag: $zoneTag}) {
          likely_human: httpRequestsAdaptiveGroups(filter: {AND: [ {botManagementDecision_neq: "verified_bot"}, $likelyHumanFilter ]}, limit: 10000) {
            count
          }
        }
      }
    }
  `;

  const variables = {
    zoneTag: zoneId,
    filter: {
      requestSource: "eyeball",
      date_geq: params.get('start_date'),
      date_leq: params.get('end_date'),
      botManagementDecision_neq: "other"
    },
    likelyHumanFilter: {
      requestSource: "eyeball",
      botScore_geq: 30,
      botScore_leq: 99,
      date_geq: params.get('start_date'),
      date_leq: params.get('end_date'),
      botManagementDecision_neq: "other"
    }
  };

  return await performGraphQLRequest(query, variables);
}



async function handleFoundationDNSQueries(accountTag, zoneIds, params) {
  const startDate = params.get('start_date');
  const endDate = params.get('end_date');
  
  let zoneResults = {};
  let totalQueryCount = 0;
  let validZoneCount = 0;

  for (const zoneId of zoneIds) {
    const url = `https://api.cloudflare.com/client/v4/zones/${zoneId}/dns_analytics/report?metrics=queryCount&sort=-queryCount&limit=100&since=${startDate}T00:00:00Z&until=${endDate}T00:00:00Z`;

    try {
      const response = await fetch(url, {
        headers: {
          'X-Auth-Email': AUTH_EMAIL,
          'X-Auth-Key': AUTH_KEY,
          'Content-Type': 'application/json'
        }
      });

      const data = await response.json();
      zoneResults[zoneId] = data;

      // Check if the response contains valid query count data
      if (data.success && data.result && data.result.totals && data.result.totals.queryCount) {
        totalQueryCount += data.result.totals.queryCount;
        validZoneCount++;
      }
    } catch (error) {
      console.error(`Error fetching data for zone ${zoneId}:`, error);
      zoneResults[zoneId] = { error: error.message };
    }
  }

  return {
    zoneResults,
    summary: {
      totalQueryCount,
      validZoneCount,
      averageQueryCount: validZoneCount > 0 ? totalQueryCount / validZoneCount : 0
    }
  };
}

function processEndpointResult(endpoint, result) {
  if (!result.data || !result.data.viewer || !result.data.viewer.zones || result.data.viewer.zones.length === 0) {
    console.error(`Invalid result structure for endpoint ${endpoint}:`, result);
    return null;
  }

  switch (endpoint) {
    case 'data_transfer_request':
      const groups = result.data.viewer.zones[0].httpRequestsOverviewAdaptiveGroups;
      if (groups && groups.length > 0) {
        return {
          bytes: groups[0].sum.bytes,
          requests: groups[0].sum.requests
        };
      }
      return null;
    case 'bot_management_request':
      const likelyHuman = result.data.viewer.zones[0].likely_human;
      if (likelyHuman && likelyHuman.length > 0) {
        return likelyHuman[0].count;
      }
      return null;

    case 'foundation_dns_queries':
      return result.data.viewer.zones[0].dns.analytics.queries.count;
    case 'china_ntw_data_transfer':
      const chinaGroups = result.data.viewer.zones[0].httpRequests1dGroups;
      return chinaGroups && chinaGroups.length > 0 ? chinaGroups[0].sum.bytes : null;
    // 다른 엔드포인트에 대한 처리를 추가할 수 있습니다.
    default:
      console.error(`Unknown endpoint: ${endpoint}`);
      return null;
  }
}


async function getZoneIds(customerName) {
  // KV에서 고객사의 zone ID들을 가져옵니다.
  const zonesData = await ZONES.get(`zones_${customerName}`);
  if (!zonesData) {
    throw new Error(`No zones found for customer: ${customerName}`);
  }
  const zones = JSON.parse(zonesData);
  return Object.values(zones);
}

async function performGraphQLRequest(query, variables = {}) {
  const response = await fetch('https://api.cloudflare.com/client/v4/graphql', {
    method: 'POST',
    headers: {
      'X-Auth-Email': AUTH_EMAIL,
      'X-Auth-Key': AUTH_KEY,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ query, variables })
  });
  return await response.json();
}

// Endpoint handler functions




async function handleChinaNtwDataTransfer(accountTag, zoneId, params) {
  const query = `
    query getChinaDataTransfer($zoneId: String!, $start: String!, $end: String!) {
      viewer {
        zones(filter: {zoneTag: $zoneId}) {
          httpRequests1dGroups(limit: 1, filter: {date_geq: $start, date_leq: $end, clientCountryName: "CN"}) {
            sum {
              bytes
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    zoneId, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}


// Endpoint handler functions


async function handleWorkersStdRequests(accountTag, zoneId, params) {
  const query = `
    query getWorkersRequests($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          workersInvocations(filter: {date_geq: $start, date_leq: $end}) {
            sum {
              requests
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleWorkersStdCPU(accountTag, zoneId, params) {
  const query = `
    query getWorkersCPU($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          workersInvocations(filter: {date_geq: $start, date_leq: $end}) {
            sum {
              cpuTime
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleWorkersKVRead(accountTag, zoneId, params) {
  const query = `
    query getWorkersKVRead($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          workersInvocations(filter: {date_geq: $start, date_leq: $end}) {
            sum {
              kvRequests
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleWorkersKVStorage(accountTag, zoneId, params) {
  const query = `
    query getWorkersKVStorage($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          workersKvProperties {
            kvUsage(filter: {date_geq: $start, date_leq: $end}) {
              sum {
                storedBytes
              }
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleWorkersKVWriteListDelete(accountTag, zoneId, params) {
  const query = `
    query getWorkersKVWriteListDelete($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          workersKvProperties {
            kvUsage(filter: {date_geq: $start, date_leq: $end}) {
              sum {
                writtenBytes
                deletedKeys
                listedKeys
              }
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleStreamMinutesStored(accountTag, zoneId, params) {
  const query = `
    query getStreamMinutesStored($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          stream {
            minutesStored(filter: {date_geq: $start, date_leq: $end}) {
              sum {
                minutes
              }
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleStreamMinutesViewed(accountTag, zoneId, params) {
  const query = `
    query getStreamMinutesViewed($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          stream {
            minutesDelivered(filter: {date_geq: $start, date_leq: $end}) {
              sum {
                minutes
              }
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleImagesDelivered(accountTag, zoneId, params) {
  const query = `
    query getImagesDelivered($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          imagesAdaptiveGroups(filter: {date_geq: $start, date_leq: $end}) {
            sum {
              requests
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleImagesStored(accountTag, zoneId, params) {
  const query = `
    query getImagesStored($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          imagesAdaptiveGroups(filter: {date_geq: $start, date_leq: $end}) {
            sum {
              bytes
            }
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}

async function handleImagesUniqueTransformations(accountTag, zoneId, params) {
  const query = `
    query getImagesUniqueTransformations($accountTag: String!, $start: String!, $end: String!) {
      viewer {
        accounts(filter: {accountTag: $accountTag}) {
          imagesAdaptiveGroups(filter: {date_geq: $start, date_leq: $end}) {
            count
          }
        }
      }
    }
  `;
  return await performGraphQLRequest(query, { 
    accountTag, 
    start: params.get('start_date'), 
    end: params.get('end_date') 
  });
}
